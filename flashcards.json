[
    {
        "term": "Class",
        "description": "A blueprint for creating objects that define properties and methods. \n Example: class Dog { }"
    },
    {
        "term": "Object",
        "description": "An instance of a class containing data and behavior. \n Example: let myDog = new Dog();"
    },
    {
        "term": "Inheritance",
        "description": "A mechanism where a new class derives properties and behavior from an existing class. \n Example: class Puppy extends Dog { }"
    },
    {
        "term": "Encapsulation",
        "description": "The bundling of data and methods that operate on that data, restricting access to some components. \n Example: private int age; in a class to hide the age property."
    },
    {
        "term": "Polymorphism",
        "description": "The ability to present the same interface for different underlying data types, enabling method overriding and interface implementation. \n Example: function makeSound(animal) { animal.sound(); }"
    },
    {
        "term": "Abstraction",
        "description": "The concept of hiding complex reality while exposing only the necessary parts, often using abstract classes and interfaces. \n Example: abstract class Animal { abstract sound(); }"
    },
    {
        "term": "Interface",
        "description": "A contract that defines methods without implementing them, allowing different classes to implement the same interface. \n Example: interface Swimmable { void swim(); }"
    },
    {
        "term": "Constructor",
        "description": "A special method called when an object is instantiated, used to initialize properties. \n Example: constructor(name) { this.name = name; }"
    },
    {
        "term": "Method",
        "description": "A function defined within a class that describes the behaviors of an object. \n Example: bark() { console.log('Woof!'); }"
    },
    {
        "term": "Overloading",
        "description": "Defining multiple methods with the same name but different parameters, allowing different functionalities based on input types. \n Example: function add(a, b) { return a + b; }"
    },
    {
        "term": "Overriding",
        "description": "A feature that allows a subclass to provide a specific implementation of a method already defined in its superclass. \n Example: class Dog { bark() { return 'Woof!'; } } class Puppy extends Dog { bark() { return 'Yip!'; } }"
    },
    {
        "term": "Composition",
        "description": "A design principle where one class contains references to objects of other classes, promoting code reuse. \n Example: class Owner { Dog pet; }"
    },
    {
        "term": "Aggregation",
        "description": "A special form of association where a class contains references to other classes, indicating a 'whole-part' relationship. \n Example: class Library { Book[] books; }"
    },
    {
        "term": "Association",
        "description": "A relationship where one class uses another class, but without ownership semantics. \n Example: class Driver { Car car; }"
    },
    {
        "term": "Static Method",
        "description": "A method that belongs to the class rather than any instance, called without creating an instance. \n Example: static add(a, b) { return a + b; }"
    },
    {
        "term": "Instance Variable",
        "description": "A variable defined in a class for which each object of the class has a separate copy. \n Example: this.name in a class Person."
    },
    {
        "term": "Class Variable",
        "description": "A variable defined in a class that is shared among all instances of that class. \n Example: static count in a class to track the number of instances."
    },
    {
        "term": "Final/Const",
        "description": "A keyword used to define constants that cannot be changed after being initialized. \n Example: final int MAX_AGE = 100;"
    },
    {
        "term": "Access Modifiers",
        "description": "Keywords that set the accessibility of classes, methods, and other members. Common types include public, private, and protected. \n Example: private void myMethod() { }"
    },
    {
        "term": "Design Patterns",
        "description": "Standardized solutions to common software design problems, such as Singleton, Observer, and Factory patterns. \n Example: Singleton ensures a class has only one instance."
    },
    {
        "term": "Error Handling",
        "description": "Mechanisms to respond to exceptions or errors that occur during program execution, often using try-catch blocks. \n Example: try { riskyOperation(); } catch (Exception e) { handleError(e); }"
    }
]
